"""
AI-driven Vulnerability Prioritization Engine
"""
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
from loguru import logger

from app.models.vulnerability import (
    VulnerabilitySeverity,
    VulnerabilityCreate,
    VulnerabilityTriageResult
)


class VulnerabilityPrioritizer:
    """AI-driven vulnerability prioritization engine"""
    
    def __init__(self):
        logger.info("âœ… Vulnerability prioritizer initialized")
    
    def calculate_priority_score(
        self,
        cvss_score: float,
        exploitability: str,
        business_impact: str,
        affected_components: List[str],
        exposure_level: str = "unknown"
    ) -> float:
        """
        Calculate priority score (0-100) for vulnerability prioritization
        
        Factors:
        - CVSS score (base)
        - Exploitability (active exploits, PoC available)
        - Business impact (critical services affected)
        - Exposure level (internet-facing, internal only)
        - Affected components count
        """
        # Base score from CVSS (0-10 scale, convert to 0-50)
        base_score = (cvss_score / 10.0) * 50
        
        # Exploitability multiplier
        exploitability_multipliers = {
            "active_exploits": 1.5,
            "poc_available": 1.3,
            "theoretical": 1.0,
            "none": 0.8
        }
        exploit_multiplier = exploitability_multipliers.get(exploitability.lower(), 1.0)
        
        # Business impact multiplier
        impact_multipliers = {
            "critical": 1.5,  # Customer-facing, payment processing
            "high": 1.3,      # Internal critical systems
            "medium": 1.1,    # Internal systems
            "low": 1.0        # Non-critical
        }
        impact_multiplier = impact_multipliers.get(business_impact.lower(), 1.0)
        
        # Exposure multiplier
        exposure_multipliers = {
            "internet_facing": 1.4,
            "dmz": 1.2,
            "internal": 1.0,
            "isolated": 0.8
        }
        exposure_multiplier = exposure_multipliers.get(exposure_level.lower(), 1.0)
        
        # Component count bonus (more components = higher priority)
        component_bonus = min(len(affected_components) * 2, 10)
        
        # Calculate final score
        priority_score = (base_score * exploit_multiplier * impact_multiplier * exposure_multiplier) + component_bonus
        
        # Cap at 100
        return min(priority_score, 100.0)
    
    def determine_severity(self, cvss_score: float) -> VulnerabilitySeverity:
        """Determine severity from CVSS score"""
        if cvss_score >= 9.0:
            return VulnerabilitySeverity.CRITICAL
        elif cvss_score >= 7.0:
            return VulnerabilitySeverity.HIGH
        elif cvss_score >= 4.0:
            return VulnerabilitySeverity.MEDIUM
        elif cvss_score > 0.0:
            return VulnerabilitySeverity.LOW
        else:
            return VulnerabilitySeverity.INFO
    
    def calculate_sla_days(self, severity: VulnerabilitySeverity, priority_score: float) -> int:
        """Calculate SLA deadline in days based on severity and priority"""
        # Base SLA by severity
        base_sla = {
            VulnerabilitySeverity.CRITICAL: 1,   # 1 day
            VulnerabilitySeverity.HIGH: 7,     # 7 days
            VulnerabilitySeverity.MEDIUM: 30,  # 30 days
            VulnerabilitySeverity.LOW: 90,      # 90 days
            VulnerabilitySeverity.INFO: 90      # 90 days
        }
        
        base_days = base_sla.get(severity, 30)
        
        # Adjust based on priority score
        if priority_score >= 80:
            return max(base_days - 2, 1)  # High priority = faster SLA
        elif priority_score >= 60:
            return base_days
        else:
            return base_days + 7  # Lower priority = more time
        
        return base_days
    
    def determine_remediation_urgency(self, priority_score: float, severity: VulnerabilitySeverity) -> str:
        """Determine remediation urgency"""
        if priority_score >= 80 or severity == VulnerabilitySeverity.CRITICAL:
            return "immediate"
        elif priority_score >= 60 or severity == VulnerabilitySeverity.HIGH:
            return "high"
        elif priority_score >= 40:
            return "medium"
        else:
            return "low"
    
    def triage_vulnerability(
        self,
        vulnerability: VulnerabilityCreate,
        exploitability: Optional[str] = None,
        business_impact: Optional[str] = None,
        exposure_level: Optional[str] = None,
        rag_context: Optional[List[Dict[str, Any]]] = None
    ) -> VulnerabilityTriageResult:
        """
        Triage a vulnerability using AI-driven prioritization
        
        Args:
            vulnerability: Vulnerability to triage
            exploitability: Exploitability level (active_exploits, poc_available, etc.)
            business_impact: Business impact (critical, high, medium, low)
            exposure_level: Exposure level (internet_facing, dmz, internal, isolated)
            rag_context: Relevant documentation from RAG
            
        Returns:
            Triage result with priority score and recommendations
        """
        # Auto-detect if not provided
        if not exploitability:
            exploitability = self._detect_exploitability(vulnerability, rag_context)
        
        if not business_impact:
            business_impact = self._assess_business_impact(vulnerability.affected_components)
        
        if not exposure_level:
            exposure_level = "internal"  # Default, can be enhanced
        
        # Calculate priority score
        priority_score = self.calculate_priority_score(
            cvss_score=vulnerability.cvss_score,
            exploitability=exploitability,
            business_impact=business_impact,
            affected_components=vulnerability.affected_components,
            exposure_level=exposure_level
        )
        
        # Determine severity
        severity = self.determine_severity(vulnerability.cvss_score)
        
        # Calculate SLA
        sla_days = self.calculate_sla_days(severity, priority_score)
        sla_deadline = datetime.utcnow() + timedelta(days=sla_days)
        
        # Determine urgency
        urgency = self.determine_remediation_urgency(priority_score, severity)
        
        # Generate remediation guidance from RAG context
        remediation_guidance = None
        if rag_context:
            remediation_guidance = self._extract_remediation_guidance(rag_context)
        
        return VulnerabilityTriageResult(
            vulnerability_id="",  # Will be set by caller
            priority_score=priority_score,
            severity=severity,
            business_impact=business_impact,
            exploitability=exploitability,
            recommended_team=None,  # Will be set by ownership assignment
            recommended_owner=None,
            sla_days=sla_days,
            remediation_urgency=urgency,
            relevant_docs=rag_context or [],
            remediation_guidance=remediation_guidance
        )
    
    def _detect_exploitability(
        self,
        vulnerability: VulnerabilityCreate,
        rag_context: Optional[List[Dict[str, Any]]]
    ) -> str:
        """Detect exploitability level from vulnerability data and RAG context"""
        # Check description for exploit indicators
        description_lower = vulnerability.description.lower()
        
        if any(term in description_lower for term in ["active exploit", "exploited in the wild", "actively exploited"]):
            return "active_exploits"
        elif any(term in description_lower for term in ["proof of concept", "poc", "exploit code"]):
            return "poc_available"
        elif any(term in description_lower for term in ["theoretical", "potential"]):
            return "theoretical"
        else:
            return "none"
    
    def _assess_business_impact(self, affected_components: List[str]) -> str:
        """Assess business impact based on affected components"""
        critical_keywords = ["payment", "auth", "api", "database", "customer"]
        high_keywords = ["internal", "admin", "monitoring"]
        
        components_str = " ".join(affected_components).lower()
        
        if any(keyword in components_str for keyword in critical_keywords):
            return "critical"
        elif any(keyword in components_str for keyword in high_keywords):
            return "high"
        elif len(affected_components) > 5:
            return "medium"
        else:
            return "low"
    
    def _extract_remediation_guidance(self, rag_context: List[Dict[str, Any]]) -> Optional[str]:
        """Extract remediation guidance from RAG context"""
        if not rag_context:
            return None
        
        # Combine relevant documentation
        guidance_parts = []
        for doc in rag_context[:3]:  # Top 3 most relevant
            content = doc.get('content', '')
            # Extract actionable guidance (sentences with "should", "must", "recommend")
            sentences = content.split('.')
            for sentence in sentences:
                if any(word in sentence.lower() for word in ['should', 'must', 'recommend', 'patch', 'update', 'upgrade']):
                    guidance_parts.append(sentence.strip())
        
        return ". ".join(guidance_parts[:5]) if guidance_parts else None

